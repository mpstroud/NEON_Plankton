---
title: "Site-specific Data Merge"
author: "Marc Peipoch"
date: "9/16/2022"
output: html_document
---

This script must be run after 'OneSite_WatQualDataDownload_withQAQC' & 'OneSite_WatQuantityDownload_withRatingCurve' have been completed since it requires the annual QAQC files generated by boths scripts.


```{r setup, include=FALSE}
library(neonUtilities) ; library(dplyr) ; library(lubridate) ; library(EcoHydRology); library(tidyr) ; 
library(xts) ; library(lubridate)
options(stringsAsFactors=F) # character variables are not converted to factors

setwd("R:/EcosystemEcologyLab/MSAPLANKTONdataDirectory/DataInDevelopment/NEONData/TOMB/01_input")
```



```{r}
########need to readjust per each year###########################
  
  wat_quant = read.csv("wquant_data_QApass_2017.csv", header = T)
  
  wat_qual = read.csv("wq_data_QApass_2017.csv", header = T)

#################################################################

#Perform the baseflow separation using the EcoHydRology package for each water year. This will return a 2 column data frame with nrow = length of input streamflow data. The first column contains baseflow, while the second contains quickflow, both in the same units as the input.

  wat_quant$withParaUncQMean = 0.0283168*wat_quant$usgsDischarge ###########################transfrom USGS discharge into m3s-1 and rename
  temp = BaseflowSeparation(wat_quant$withParaUncQMean, filter_parameter = 0.99, passes = 3)
    wat_quant$withParaUncQMean_base = temp[,1] #baseflow
      wat_quant$withParaUncQMean_Propbase = ((wat_quant$withParaUncQMean - wat_quant$withParaUncQMean_base)
                                                    /wat_quant$withParaUncQMean) #percent of instant flow classified as baseflow

#create subsets of water qual and quant datasets and merge them by datetime

wat_quant_subset = data.frame(matrix(ncol=0,nrow=nrow(wat_quant)))

wat_quant_subset$datetime = wat_quant$endDate
wat_quant_subset$meanFlow = wat_quant$withParaUncQMean
wat_quant_subset$sdFlow = wat_quant$withParaUncQMean - (0.0283168*wat_quant$withRegressionUncQLower1Std) ##########################
wat_quant_subset$propBaseFlow = wat_quant$withParaUncQMean_Propbase


wat_qual_subset = data.frame(matrix(ncol=0,nrow=nrow(wat_qual)))

wat_qual_subset$datetime = wat_qual$startDateTime
wat_qual_subset$chlorophyll = wat_qual$chlorophyll
wat_qual_subset$chl_unc = wat_qual$chlorophyllExpUncert
wat_qual_subset$turbidity = wat_qual$turbidity
wat_qual_subset$turb_unc = wat_qual$turbidityExpUncert

#both datasets are at 1-min interval, and not necessarily the same one, 
#aggregate each dataset to 5-minute intervals

wat_quant_subset$datetime = as.POSIXct(wat_quant_subset$datetime, format = "%Y-%m-%d %H:%M:%S")
wat_quant_subset2 = na.omit(wat_quant_subset) #remove NAs or xts object will crash
if ((nrow(wat_quant_subset) - nrow(wat_quant_subset2)) > 48000){ 
  print("fix NAs") } 
qxts <- xts(wat_quant_subset2[,2:4], order.by=wat_quant_subset2[,1]) #create xts object
wat_quant_subset_avg = period.apply(qxts, endpoints(qxts, "minutes", 30), mean) #average every 30 minutes 
wat_quant_subset_avg = as.data.frame(wat_quant_subset_avg) #reverse to data frame and fix the datetime vector
wat_quant_subset_avg$datetime = row.names(wat_quant_subset_avg) ; row.names(wat_quant_subset_avg) = NULL
wat_quant_subset_avg$datetime = as.POSIXct(wat_quant_subset_avg$datetime, #format datetime vector to round to neares 30min using lubridate::round_date
                                          format = "%Y-%m-%d %H:%M:%S")
wat_quant_subset_avg$datetime = round_date(wat_quant_subset_avg$datetime,unit="30 minutes")



wat_qual_subset$datetime = as.POSIXct(wat_qual_subset$datetime, format = "%Y-%m-%d %H:%M:%S")
wat_qual_subset2 = na.omit(wat_qual_subset) #remove NAs or xts object will crash
if ((nrow(wat_qual_subset) - nrow(wat_qual_subset2)) > 48000){ 
  print("fix NAs") } 
qxts <- xts(wat_qual_subset2[,2:5], order.by=wat_qual_subset2[,1]) #create xts object
wat_qual_subset_avg = period.apply(qxts, endpoints(qxts, "minutes", 30), mean) #average every 30 minutes 
wat_qual_subset_avg = as.data.frame(wat_qual_subset_avg) #reverse to data frame and fix the datetime vector
wat_qual_subset_avg$datetime = row.names(wat_qual_subset_avg) ; row.names(wat_qual_subset_avg) = NULL
wat_qual_subset_avg$datetime = as.POSIXct(wat_qual_subset_avg$datetime, #format datetime vector to round to neares 30min using lubridate::round_date
                                          format = "%Y-%m-%d %H:%M:%S")
wat_qual_subset_avg$datetime = round_date(wat_qual_subset_avg$datetime,unit="30 minutes")
 

#################################################################

#merge datasets by datetime
final_merged_data_30min = left_join(wat_qual_subset_avg,wat_quant_subset_avg,by="datetime")

write.csv(final_merged_data_30min, 
          "R:/EcosystemEcologyLab/MSAPLANKTONdataDirectory/DataInDevelopment/NEONData/TOMB/03_incremental/final_data_30min_2017.csv", 
          row.names=F)








########need to readjust per each year###########################
  
  wat_quant = read.csv("wquant_data_QApass_2018.csv", header = T)
  
  wat_qual = read.csv("wq_data_QApass_2018.csv", header = T)

#################################################################

#Perform the baseflow separation using the EcoHydRology package for each water year. This will return a 2 column data frame with nrow = length of input streamflow data. The first column contains baseflow, while the second contains quickflow, both in the same units as the input.

  wat_quant$withParaUncQMean = 0.0283168*wat_quant$usgsDischarge ###########################transfrom USGS discharge into m3s-1 and rename
  temp = BaseflowSeparation(wat_quant$withParaUncQMean, filter_parameter = 0.99, passes = 3)
    wat_quant$withParaUncQMean_base = temp[,1] #baseflow
      wat_quant$withParaUncQMean_Propbase = ((wat_quant$withParaUncQMean - wat_quant$withParaUncQMean_base)
                                                    /wat_quant$withParaUncQMean) #percent of instant flow classified as baseflow

#create subsets of water qual and quant datasets and merge them by datetime

wat_quant_subset = data.frame(matrix(ncol=0,nrow=nrow(wat_quant)))

wat_quant_subset$datetime = wat_quant$endDate
wat_quant_subset$meanFlow = wat_quant$withParaUncQMean
wat_quant_subset$sdFlow = wat_quant$withParaUncQMean - (0.0283168*wat_quant$withRegressionUncQLower1Std) ##########################
wat_quant_subset$propBaseFlow = wat_quant$withParaUncQMean_Propbase


wat_qual_subset = data.frame(matrix(ncol=0,nrow=nrow(wat_qual)))

wat_qual_subset$datetime = wat_qual$startDateTime
wat_qual_subset$chlorophyll = wat_qual$chlorophyll
wat_qual_subset$chl_unc = wat_qual$chlorophyllExpUncert
wat_qual_subset$turbidity = wat_qual$turbidity
wat_qual_subset$turb_unc = wat_qual$turbidityExpUncert

#both datasets are at 1-min interval, and not necessarily the same one, 
#aggregate each dataset to 5-minute intervals

wat_quant_subset$datetime = as.POSIXct(wat_quant_subset$datetime, format = "%Y-%m-%d %H:%M:%S")
wat_quant_subset2 = na.omit(wat_quant_subset) #remove NAs or xts object will crash
if ((nrow(wat_quant_subset) - nrow(wat_quant_subset2)) > 48000){ 
  print("fix NAs") } 
qxts <- xts(wat_quant_subset2[,2:4], order.by=wat_quant_subset2[,1]) #create xts object
wat_quant_subset_avg = period.apply(qxts, endpoints(qxts, "minutes", 30), mean) #average every 30 minutes 
wat_quant_subset_avg = as.data.frame(wat_quant_subset_avg) #reverse to data frame and fix the datetime vector
wat_quant_subset_avg$datetime = row.names(wat_quant_subset_avg) ; row.names(wat_quant_subset_avg) = NULL
wat_quant_subset_avg$datetime = as.POSIXct(wat_quant_subset_avg$datetime, #format datetime vector to round to neares 30min using lubridate::round_date
                                          format = "%Y-%m-%d %H:%M:%S")
wat_quant_subset_avg$datetime = round_date(wat_quant_subset_avg$datetime,unit="30 minutes")



wat_qual_subset$datetime = as.POSIXct(wat_qual_subset$datetime, format = "%Y-%m-%d %H:%M:%S")
wat_qual_subset2 = na.omit(wat_qual_subset) #remove NAs or xts object will crash
if ((nrow(wat_qual_subset) - nrow(wat_qual_subset2)) > 48000){ 
  print("fix NAs") } 
qxts <- xts(wat_qual_subset2[,2:5], order.by=wat_qual_subset2[,1]) #create xts object
wat_qual_subset_avg = period.apply(qxts, endpoints(qxts, "minutes", 30), mean) #average every 30 minutes 
wat_qual_subset_avg = as.data.frame(wat_qual_subset_avg) #reverse to data frame and fix the datetime vector
wat_qual_subset_avg$datetime = row.names(wat_qual_subset_avg) ; row.names(wat_qual_subset_avg) = NULL
wat_qual_subset_avg$datetime = as.POSIXct(wat_qual_subset_avg$datetime, #format datetime vector to round to neares 30min using lubridate::round_date
                                          format = "%Y-%m-%d %H:%M:%S")
wat_qual_subset_avg$datetime = round_date(wat_qual_subset_avg$datetime,unit="30 minutes")
 


#################################################################

#merge datasets by datetime
final_merged_data_30min = left_join(wat_qual_subset_avg,wat_quant_subset_avg,by="datetime")

write.csv(final_merged_data_30min, 
          "R:/EcosystemEcologyLab/MSAPLANKTONdataDirectory/DataInDevelopment/NEONData/TOMB/03_incremental/final_data_30min_2018.csv", 
          row.names=F)





########need to readjust per each year###########################
  
  wat_quant = read.csv("wquant_data_QApass_2019.csv", header = T)
  
  wat_qual = read.csv("wq_data_QApass_2019.csv", header = T)

#################################################################

#Perform the baseflow separation using the EcoHydRology package for each water year. This will return a 2 column data frame with nrow = length of input streamflow data. The first column contains baseflow, while the second contains quickflow, both in the same units as the input.

  wat_quant$withParaUncQMean = 0.0283168*wat_quant$usgsDischarge ###########################transfrom USGS discharge into m3s-1 and rename
  temp = BaseflowSeparation(wat_quant$withParaUncQMean, filter_parameter = 0.99, passes = 3)
    wat_quant$withParaUncQMean_base = temp[,1] #baseflow
      wat_quant$withParaUncQMean_Propbase = ((wat_quant$withParaUncQMean - wat_quant$withParaUncQMean_base)
                                                    /wat_quant$withParaUncQMean) #percent of instant flow classified as baseflow

#create subsets of water qual and quant datasets and merge them by datetime

wat_quant_subset = data.frame(matrix(ncol=0,nrow=nrow(wat_quant)))

wat_quant_subset$datetime = wat_quant$endDate
wat_quant_subset$meanFlow = wat_quant$withParaUncQMean
wat_quant_subset$sdFlow = wat_quant$withParaUncQMean - (0.0283168*wat_quant$withRegressionUncQLower1Std) ##########################
wat_quant_subset$propBaseFlow = wat_quant$withParaUncQMean_Propbase


wat_qual_subset = data.frame(matrix(ncol=0,nrow=nrow(wat_qual)))

wat_qual_subset$datetime = wat_qual$startDateTime
wat_qual_subset$chlorophyll = wat_qual$chlorophyll
wat_qual_subset$chl_unc = wat_qual$chlorophyllExpUncert
wat_qual_subset$turbidity = wat_qual$turbidity
wat_qual_subset$turb_unc = wat_qual$turbidityExpUncert

#both datasets are at 1-min interval, and not necessarily the same one, 
#aggregate each dataset to 5-minute intervals

wat_quant_subset$datetime = as.POSIXct(wat_quant_subset$datetime, format = "%Y-%m-%d %H:%M:%S")
wat_quant_subset2 = na.omit(wat_quant_subset) #remove NAs or xts object will crash
if ((nrow(wat_quant_subset) - nrow(wat_quant_subset2)) > 48000){ 
  print("fix NAs") } 
qxts <- xts(wat_quant_subset2[,2:4], order.by=wat_quant_subset2[,1]) #create xts object
wat_quant_subset_avg = period.apply(qxts, endpoints(qxts, "minutes", 30), mean) #average every 30 minutes 
wat_quant_subset_avg = as.data.frame(wat_quant_subset_avg) #reverse to data frame and fix the datetime vector
wat_quant_subset_avg$datetime = row.names(wat_quant_subset_avg) ; row.names(wat_quant_subset_avg) = NULL
wat_quant_subset_avg$datetime = as.POSIXct(wat_quant_subset_avg$datetime, #format datetime vector to round to neares 30min using lubridate::round_date
                                          format = "%Y-%m-%d %H:%M:%S")
wat_quant_subset_avg$datetime = round_date(wat_quant_subset_avg$datetime,unit="30 minutes")



wat_qual_subset$datetime = as.POSIXct(wat_qual_subset$datetime, format = "%Y-%m-%d %H:%M:%S")
wat_qual_subset2 = na.omit(wat_qual_subset) #remove NAs or xts object will crash
if ((nrow(wat_qual_subset) - nrow(wat_qual_subset2)) > 48000){ 
  print("fix NAs") } 
qxts <- xts(wat_qual_subset2[,2:5], order.by=wat_qual_subset2[,1]) #create xts object
wat_qual_subset_avg = period.apply(qxts, endpoints(qxts, "minutes", 30), mean) #average every 30 minutes 
wat_qual_subset_avg = as.data.frame(wat_qual_subset_avg) #reverse to data frame and fix the datetime vector
wat_qual_subset_avg$datetime = row.names(wat_qual_subset_avg) ; row.names(wat_qual_subset_avg) = NULL
wat_qual_subset_avg$datetime = as.POSIXct(wat_qual_subset_avg$datetime, #format datetime vector to round to neares 30min using lubridate::round_date
                                          format = "%Y-%m-%d %H:%M:%S")
wat_qual_subset_avg$datetime = round_date(wat_qual_subset_avg$datetime,unit="30 minutes")
 

#################################################################

#merge datasets by datetime
final_merged_data_30min = left_join(wat_qual_subset_avg,wat_quant_subset_avg,by="datetime")

write.csv(final_merged_data_30min, 
          "R:/EcosystemEcologyLab/MSAPLANKTONdataDirectory/DataInDevelopment/NEONData/TOMB/03_incremental/final_data_30min_2019.csv", 
          row.names=F)









########need to readjust per each year###########################
  
  wat_quant = read.csv("wquant_data_QApass_2020.csv", header = T)
  
  wat_qual = read.csv("wq_data_QApass_2020.csv", header = T)

#################################################################

#Perform the baseflow separation using the EcoHydRology package for each water year. This will return a 2 column data frame with nrow = length of input streamflow data. The first column contains baseflow, while the second contains quickflow, both in the same units as the input.

  wat_quant$withParaUncQMean = 0.0283168*wat_quant$usgsDischarge ###########################transfrom USGS discharge into m3s-1 and rename
  temp = BaseflowSeparation(wat_quant$withParaUncQMean, filter_parameter = 0.99, passes = 3)
    wat_quant$withParaUncQMean_base = temp[,1] #baseflow
      wat_quant$withParaUncQMean_Propbase = ((wat_quant$withParaUncQMean - wat_quant$withParaUncQMean_base)
                                                    /wat_quant$withParaUncQMean) #percent of instant flow classified as baseflow

#create subsets of water qual and quant datasets and merge them by datetime

wat_quant_subset = data.frame(matrix(ncol=0,nrow=nrow(wat_quant)))

wat_quant_subset$datetime = wat_quant$endDate
wat_quant_subset$meanFlow = wat_quant$withParaUncQMean
wat_quant_subset$sdFlow = wat_quant$withParaUncQMean - (0.0283168*wat_quant$withRegressionUncQLower1Std) ##########################
wat_quant_subset$propBaseFlow = wat_quant$withParaUncQMean_Propbase


wat_qual_subset = data.frame(matrix(ncol=0,nrow=nrow(wat_qual)))

wat_qual_subset$datetime = wat_qual$startDateTime
wat_qual_subset$chlorophyll = wat_qual$chlorophyll
wat_qual_subset$chl_unc = wat_qual$chlorophyllExpUncert
wat_qual_subset$turbidity = wat_qual$turbidity
wat_qual_subset$turb_unc = wat_qual$turbidityExpUncert

#both datasets are at 1-min interval, and not necessarily the same one, 
#aggregate each dataset to 5-minute intervals

wat_quant_subset$datetime = as.POSIXct(wat_quant_subset$datetime, format = "%Y-%m-%d %H:%M:%S")
wat_quant_subset2 = na.omit(wat_quant_subset) #remove NAs or xts object will crash
if ((nrow(wat_quant_subset) - nrow(wat_quant_subset2)) > 48000){ 
  print("fix NAs") } 
qxts <- xts(wat_quant_subset2[,2:4], order.by=wat_quant_subset2[,1]) #create xts object
wat_quant_subset_avg = period.apply(qxts, endpoints(qxts, "minutes", 30), mean) #average every 30 minutes 
wat_quant_subset_avg = as.data.frame(wat_quant_subset_avg) #reverse to data frame and fix the datetime vector
wat_quant_subset_avg$datetime = row.names(wat_quant_subset_avg) ; row.names(wat_quant_subset_avg) = NULL
wat_quant_subset_avg$datetime = as.POSIXct(wat_quant_subset_avg$datetime, #format datetime vector to round to neares 30min using lubridate::round_date
                                          format = "%Y-%m-%d %H:%M:%S")
wat_quant_subset_avg$datetime = round_date(wat_quant_subset_avg$datetime,unit="30 minutes")



wat_qual_subset$datetime = as.POSIXct(wat_qual_subset$datetime, format = "%Y-%m-%d %H:%M:%S")
wat_qual_subset2 = na.omit(wat_qual_subset) #remove NAs or xts object will crash
if ((nrow(wat_qual_subset) - nrow(wat_qual_subset2)) > 48000){ 
  print("fix NAs") } 
qxts <- xts(wat_qual_subset2[,2:5], order.by=wat_qual_subset2[,1]) #create xts object
wat_qual_subset_avg = period.apply(qxts, endpoints(qxts, "minutes", 30), mean) #average every 30 minutes 
wat_qual_subset_avg = as.data.frame(wat_qual_subset_avg) #reverse to data frame and fix the datetime vector
wat_qual_subset_avg$datetime = row.names(wat_qual_subset_avg) ; row.names(wat_qual_subset_avg) = NULL
wat_qual_subset_avg$datetime = as.POSIXct(wat_qual_subset_avg$datetime, #format datetime vector to round to neares 30min using lubridate::round_date
                                          format = "%Y-%m-%d %H:%M:%S")
wat_qual_subset_avg$datetime = round_date(wat_qual_subset_avg$datetime,unit="30 minutes")
 

#################################################################

#merge datasets by datetime
final_merged_data_30min = left_join(wat_qual_subset_avg,wat_quant_subset_avg,by="datetime")

write.csv(final_merged_data_30min, 
          "R:/EcosystemEcologyLab/MSAPLANKTONdataDirectory/DataInDevelopment/NEONData/TOMB/03_incremental/final_data_30min_2020.csv", 
          row.names=F)









########need to readjust per each year###########################
  
  wat_quant = read.csv("wquant_data_QApass_2021.csv", header = T)
  
  wat_qual = read.csv("wq_data_QApass_2021.csv", header = T)

#################################################################

#Perform the baseflow separation using the EcoHydRology package for each water year. This will return a 2 column data frame with nrow = length of input streamflow data. The first column contains baseflow, while the second contains quickflow, both in the same units as the input.

  wat_quant$withParaUncQMean = 0.0283168*wat_quant$usgsDischarge ###########################transfrom USGS discharge into m3s-1 and rename
  temp = BaseflowSeparation(wat_quant$withParaUncQMean, filter_parameter = 0.99, passes = 3)
    wat_quant$withParaUncQMean_base = temp[,1] #baseflow
      wat_quant$withParaUncQMean_Propbase = ((wat_quant$withParaUncQMean - wat_quant$withParaUncQMean_base)
                                                    /wat_quant$withParaUncQMean) #percent of instant flow classified as baseflow

#create subsets of water qual and quant datasets and merge them by datetime

wat_quant_subset = data.frame(matrix(ncol=0,nrow=nrow(wat_quant)))

wat_quant_subset$datetime = wat_quant$endDate
wat_quant_subset$meanFlow = wat_quant$withParaUncQMean
wat_quant_subset$sdFlow = wat_quant$withParaUncQMean - (0.0283168*wat_quant$withRegressionUncQLower1Std) ##########################
wat_quant_subset$propBaseFlow = wat_quant$withParaUncQMean_Propbase


wat_qual_subset = data.frame(matrix(ncol=0,nrow=nrow(wat_qual)))

wat_qual_subset$datetime = wat_qual$startDateTime
wat_qual_subset$chlorophyll = wat_qual$chlorophyll
wat_qual_subset$chl_unc = wat_qual$chlorophyllExpUncert
wat_qual_subset$turbidity = wat_qual$turbidity
wat_qual_subset$turb_unc = wat_qual$turbidityExpUncert

#both datasets are at 1-min interval, and not necessarily the same one, 
#aggregate each dataset to 5-minute intervals

wat_quant_subset$datetime = as.POSIXct(wat_quant_subset$datetime, format = "%Y-%m-%d %H:%M:%S")
wat_quant_subset2 = na.omit(wat_quant_subset) #remove NAs or xts object will crash
if ((nrow(wat_quant_subset) - nrow(wat_quant_subset2)) > 48000){ 
  print("fix NAs") } 
qxts <- xts(wat_quant_subset2[,2:4], order.by=wat_quant_subset2[,1]) #create xts object
wat_quant_subset_avg = period.apply(qxts, endpoints(qxts, "minutes", 30), mean) #average every 30 minutes 
wat_quant_subset_avg = as.data.frame(wat_quant_subset_avg) #reverse to data frame and fix the datetime vector
wat_quant_subset_avg$datetime = row.names(wat_quant_subset_avg) ; row.names(wat_quant_subset_avg) = NULL
wat_quant_subset_avg$datetime = as.POSIXct(wat_quant_subset_avg$datetime, #format datetime vector to round to neares 30min using lubridate::round_date
                                          format = "%Y-%m-%d %H:%M:%S")
wat_quant_subset_avg$datetime = round_date(wat_quant_subset_avg$datetime,unit="30 minutes")



wat_qual_subset$datetime = as.POSIXct(wat_qual_subset$datetime, format = "%Y-%m-%d %H:%M:%S")
wat_qual_subset2 = na.omit(wat_qual_subset) #remove NAs or xts object will crash
if ((nrow(wat_qual_subset) - nrow(wat_qual_subset2)) > 48000){ 
  print("fix NAs") } 
qxts <- xts(wat_qual_subset2[,2:5], order.by=wat_qual_subset2[,1]) #create xts object
wat_qual_subset_avg = period.apply(qxts, endpoints(qxts, "minutes", 30), mean) #average every 30 minutes 
wat_qual_subset_avg = as.data.frame(wat_qual_subset_avg) #reverse to data frame and fix the datetime vector
wat_qual_subset_avg$datetime = row.names(wat_qual_subset_avg) ; row.names(wat_qual_subset_avg) = NULL
wat_qual_subset_avg$datetime = as.POSIXct(wat_qual_subset_avg$datetime, #format datetime vector to round to neares 30min using lubridate::round_date
                                          format = "%Y-%m-%d %H:%M:%S")
wat_qual_subset_avg$datetime = round_date(wat_qual_subset_avg$datetime,unit="30 minutes")
 

#################################################################

#merge datasets by datetime
final_merged_data_30min = left_join(wat_qual_subset_avg,wat_quant_subset_avg,by="datetime")

write.csv(final_merged_data_30min, 
          "R:/EcosystemEcologyLab/MSAPLANKTONdataDirectory/DataInDevelopment/NEONData/TOMB/03_incremental/final_data_30min_2021.csv", 
          row.names=F)






########need to readjust per each year###########################
  
  wat_quant = read.csv("wquant_data_QApass_2022.csv", header = T)
  
  wat_qual = read.csv("wq_data_QApass_2022.csv", header = T)

#################################################################

#Perform the baseflow separation using the EcoHydRology package for each water year. This will return a 2 column data frame with nrow = length of input streamflow data. The first column contains baseflow, while the second contains quickflow, both in the same units as the input.

  wat_quant$withParaUncQMean = 0.0283168*wat_quant$usgsDischarge ###########################transfrom USGS discharge into m3s-1 and rename
  temp = BaseflowSeparation(wat_quant$withParaUncQMean, filter_parameter = 0.99, passes = 3)
    wat_quant$withParaUncQMean_base = temp[,1] #baseflow
      wat_quant$withParaUncQMean_Propbase = ((wat_quant$withParaUncQMean - wat_quant$withParaUncQMean_base)
                                                    /wat_quant$withParaUncQMean) #percent of instant flow classified as baseflow

#create subsets of water qual and quant datasets and merge them by datetime

wat_quant_subset = data.frame(matrix(ncol=0,nrow=nrow(wat_quant)))

wat_quant_subset$datetime = wat_quant$endDate
wat_quant_subset$meanFlow = wat_quant$withParaUncQMean
wat_quant_subset$sdFlow = wat_quant$withParaUncQMean - (0.0283168*wat_quant$withRegressionUncQLower1Std) ##########################
wat_quant_subset$propBaseFlow = wat_quant$withParaUncQMean_Propbase


wat_qual_subset = data.frame(matrix(ncol=0,nrow=nrow(wat_qual)))

wat_qual_subset$datetime = wat_qual$startDateTime
wat_qual_subset$chlorophyll = wat_qual$chlorophyll
wat_qual_subset$chl_unc = wat_qual$chlorophyllExpUncert
wat_qual_subset$turbidity = wat_qual$turbidity
wat_qual_subset$turb_unc = wat_qual$turbidityExpUncert

#both datasets are at 1-min interval, and not necessarily the same one, 
#aggregate each dataset to 5-minute intervals

wat_quant_subset$datetime = as.POSIXct(wat_quant_subset$datetime, format = "%Y-%m-%d %H:%M:%S")
wat_quant_subset2 = na.omit(wat_quant_subset) #remove NAs or xts object will crash
if ((nrow(wat_quant_subset) - nrow(wat_quant_subset2)) > 48000){ 
  print("fix NAs") } 
qxts <- xts(wat_quant_subset2[,2:4], order.by=wat_quant_subset2[,1]) #create xts object
wat_quant_subset_avg = period.apply(qxts, endpoints(qxts, "minutes", 30), mean) #average every 30 minutes 
wat_quant_subset_avg = as.data.frame(wat_quant_subset_avg) #reverse to data frame and fix the datetime vector
wat_quant_subset_avg$datetime = row.names(wat_quant_subset_avg) ; row.names(wat_quant_subset_avg) = NULL
wat_quant_subset_avg$datetime = as.POSIXct(wat_quant_subset_avg$datetime, #format datetime vector to round to neares 30min using lubridate::round_date
                                          format = "%Y-%m-%d %H:%M:%S")
wat_quant_subset_avg$datetime = round_date(wat_quant_subset_avg$datetime,unit="30 minutes")



wat_qual_subset$datetime = as.POSIXct(wat_qual_subset$datetime, format = "%Y-%m-%d %H:%M:%S")
wat_qual_subset2 = na.omit(wat_qual_subset) #remove NAs or xts object will crash
if ((nrow(wat_qual_subset) - nrow(wat_qual_subset2)) > 48000){ 
  print("fix NAs") } 
qxts <- xts(wat_qual_subset2[,2:5], order.by=wat_qual_subset2[,1]) #create xts object
wat_qual_subset_avg = period.apply(qxts, endpoints(qxts, "minutes", 30), mean) #average every 30 minutes 
wat_qual_subset_avg = as.data.frame(wat_qual_subset_avg) #reverse to data frame and fix the datetime vector
wat_qual_subset_avg$datetime = row.names(wat_qual_subset_avg) ; row.names(wat_qual_subset_avg) = NULL
wat_qual_subset_avg$datetime = as.POSIXct(wat_qual_subset_avg$datetime, #format datetime vector to round to neares 30min using lubridate::round_date
                                          format = "%Y-%m-%d %H:%M:%S")
wat_qual_subset_avg$datetime = round_date(wat_qual_subset_avg$datetime,unit="30 minutes")
 

#################################################################

#merge datasets by datetime
final_merged_data_30min = left_join(wat_qual_subset_avg,wat_quant_subset_avg,by="datetime")

write.csv(final_merged_data_30min, 
          "R:/EcosystemEcologyLab/MSAPLANKTONdataDirectory/DataInDevelopment/NEONData/TOMB/03_incremental/final_data_30min_2022.csv", 
          row.names=F)


```


